import warnings
from collections import namedtuple

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from scipy.interpolate import UnivariateSpline
from scipy.signal import correlate

from unified_model.utils.utils import smooth_butterworth, calc_sample_delay, warp_signals, apply_scalar_functions, find_signal_limits


# TODO: Write tests
class AdcProcessor:
    """Post-processor for measured ADC data using Teensy logger.

    Attributes
    ----------
    voltage_divison_ratio : float
        The ratio of the voltage divider that was used when measuring a
        voltage using the ADC. Equal to (input voltage) / (measured voltage)
    smooth : bool
        Whether to smooth the ADC readings using a low-pass filter in order
        to remove some noise.
        Default is True.
    **smooth_kwargs :
        Keyword arguments passed to the smooth_butterworth function.

    """

    def __init__(self, voltage_division_ratio=1., smooth=True, **smooth_kwargs):
        """Constructor

        Parameters
        ----------
        voltage_divison_ratio : float
            The ratio of the voltage divider that was used when measuring a
            voltage using the ADC. Equal to (input voltage) / (measured voltage)
        smooth : bool
            Whether to smooth the ADC readings using a low-pass filter in order
            to remove some noise.
            Default is True.
        **smooth_kwargs :
            Keyword arguments passed to the smooth_butterworth function.

        See Also
        --------
        unified_model.utils.utils.smooth_butterworth : function
            Function used to perform the smoothing

        """
        self.voltage_division_ratio = voltage_division_ratio
        self.smooth = smooth
        self.smooth_kwargs = smooth_kwargs if not None else None

    def fit_transform(self,
                      groundtruth_dataframe,
                      voltage_col='V',
                      time_col='time(ms)'):
        """
        Extract and transform the voltage in pandas dataframe
        `groundtruth_dataframe` into a clean signal and normalize to the correct
        voltage.

        Parameters
        ----------
        groundtruth_dataframe : pandas dataframe
            Dataframe generated by reading in the .csv file generated by
            parsing the log files on the SD card of the data logger.
        voltage_col : string
            Column in `groundtruth_dataframe` containing the voltage readings.
        time_col : string
            Column in `groundtruth_dataframe` containing the timestamps of the
            voltage readings. Note: this is not used for any calculations.

        Returns
        -------
        numpy array
            True measured output voltage.

        numpy array
            Timestamps of each voltage measurement.
        """
        if isinstance(groundtruth_dataframe, str):
            groundtruth_dataframe = pd.read_csv(groundtruth_dataframe)

        voltage_readings = groundtruth_dataframe[voltage_col].values

        if self.smooth:
            critical_frequency = self.smooth_kwargs.pop('critical_frequency', 1 / 4)
            voltage_readings = smooth_butterworth(voltage_readings, critical_frequency)

        voltage_readings = voltage_readings * self.voltage_division_ratio
        voltage_readings = voltage_readings - np.mean(voltage_readings)

        return voltage_readings, groundtruth_dataframe[time_col].values / 1000


# TODO: Write tests
# TODO: Add Documentation
class ElectricalSystemEvaluator:
    """Evaluate the accuracy of an electrical system model's output.

    Attributes
    ----------
    emf_target : ndarray
        The target or "groundtruth" emf values produced by the electrical
        system.
    time_target : ndarray
        The corresponding timestamps of `emf_target`.
    emf_predict : ndarray
        The predicted emf values produced by the electrical system.
    time_predict : ndarray
        The corresponding timestamps of `emf_predict`.
    emf_target_ : ndarray
        The resampled target emf values. This attribute is used for producing
        the final plot using the `poof` method.
    emf_predict_ : ndarray
        The resampled predicted emf values. This attribute is used for
        producing the final plot using the `poof` method.
    time_ : ndarray
        The corresponding, shared timestamps of `emf_target_` and
        `emf_predict_`. This attribute is used for producing the final plot
        using the `poof` method.

    """

    def __init__(self, emf_target, time_target):
        """Constructor"""

        # Holds original values
        self.emf_target = emf_target
        self.time_target = time_target
        self.emf_predict = None
        self.time_predict = None

        # Holds resampled values
        self.emf_target_ = None
        self.emf_predict_ = None
        self.time_ = None

        # Holds dynamic time-warped values
        self.y_target_warped_ = None
        self.y_predict_warped_ = None

        if not self._is_period_constant(time_target):
            warnings.warn('Timestamps for the target values are not constant \
            and this may lead to undesirable behaviour.', RuntimeWarning)

    @staticmethod
    def _is_period_constant(arr):
        """Return True if the difference between values in `arr` are constant"""
        diff = np.diff(arr)
        diff = np.array([round(val, 8) for val in diff])  # Handle rounding
        if len(np.unique(diff)) > 1:
            return False
        return True

    def fit(self, emf_predict, time_predict):
        """Align `emf_predicted` and `emf_target` in time.

        This allows the target and prediction to later be compared by plotting
        them on the same time axis.

        The alignment is performed using signal correlation and resampling of
        both the target and predicted emf waveforms.

        Parameters
        ----------
        emf_predict : ndarray
            The predicted emf values produced by the electrical system.
        time_predict : ndarray
            The corresponding time values assosciated with `emf_predicted`.

        """

        self._fit(emf_predict, time_predict)

    def fit_transform(self, emf_predict, time_predict):
        self._fit(emf_predict, time_predict)
        return self.time_, self.emf_predict_

    def score(self, **metrics):
        """Calculate the score of the predicted emf values."""

        results = self._score(**metrics)
        return results

    def _score(self, **metrics):
        self.emf_predict_warped_, self.emf_target_warped_ = warp_signals(self.emf_predict_,
                                                                         self.emf_target_)
        start_index, end_index = find_signal_limits(self.emf_predict_warped_, 1)
        # Convert to integer indices, since `find_signal_limits` actually
        # returns the "time" of the signal, but we have a sampling frequency
        # of 1.
        start_index = int(start_index)
        end_index = int(end_index)
        self.emf_predict_warped_ = self.emf_predict_warped_[start_index:end_index]
        self.emf_target_warped_ = self.emf_target_warped_[start_index:end_index]

        metric_results = apply_scalar_functions(self.emf_predict_warped_,
                                                self.emf_target_warped_,
                                                **metrics)
        Results = namedtuple('Score', metric_results.keys())

        return Results(*metric_results.values())

    def poof(self, include_dtw=False, **kwargs):
        """Plot the aligned target and predicted values.

        Parameters
        ----------
        kwargs:
            Kwargs passed to matplotlib.pyplot.plot function.

        """
        plt.plot(self.time_, self.emf_target_, label='Target', **kwargs)
        plt.plot(self.time_, self.emf_predict_, label='Predictions', **kwargs)
        plt.legend()

        if include_dtw:
            plt.figure()
            plt.plot(self.emf_target_warped_, label='Target, time-warped')
            plt.plot(self.emf_predict_warped_, label='Prediction, time-warped')
            plt.legend()
        plt.show()

    def _fit(self, emf_predict, time_predict):

        self.emf_predicted = emf_predict
        self.time_predicted = time_predict

        if not self._is_period_constant(time_predict):
            warnings.warn('Timestamps for the predicted values are not constant \
            and this may lead to undesirable behaviour.', RuntimeWarning)

        # Normalize
        emf_predict = np.abs(emf_predict)

        # Build interpolators in order to resample.
        interp_target = UnivariateSpline(self.time_target,
                                         self.emf_target,
                                         s=0,
                                         ext='zeros')
        interp_pred = UnivariateSpline(time_predict,
                                       emf_predict,
                                       s=0,
                                       ext='zeros')

        # Resample (must calculate cross-correlation with same sampling rate!)
        stop_time = np.max([self.time_target[-1], time_predict[-1]])
        resampled_timesteps = np.linspace(0, stop_time, 10000)

        resampled_emf_target = interp_target(resampled_timesteps)
        resampled_emf_pred = interp_pred(resampled_timesteps)

        # Calculate delay using cross-correlation
        corr_1 = correlate(resampled_emf_pred, resampled_emf_target)
        corr_2 = correlate(resampled_emf_target, resampled_emf_pred)
        sample_offset = int((np.abs(np.argmax(corr_1) - np.argmax(corr_2))) / 2)
        time_offset = resampled_timesteps[sample_offset]

        # TODO: Design some mechanism to shift the correct signal
        # TODO: For now, we're assuming the predicted signal is
        # TODO: always leading.
        # Compensate for delay
        interp_pred = UnivariateSpline(resampled_timesteps + time_offset,
                                       resampled_emf_pred,
                                       s=0,
                                       ext='zeros')
        resampled_emf_pred = interp_pred(resampled_timesteps)

        self.emf_target_ = resampled_emf_target
        self.emf_predict_ = resampled_emf_pred
        self.time_ = resampled_timesteps


class LabeledVideoProcessor:
    """Post-processor for labeled magnet-assembly data.

    Attributes
    ----------
    L : float
        Height of the microgenerator tube in mm.
    mf : float
        Height of the fixed magnet at the bottom of the tube in mm.
    mm : float
        Height of the moving magnet assembly in mm.
    seconds_per_frame : float
        Number of seconds per frame / datapoint.
        This is typically found in the `subsampled_seconds_per_frame` key
        of the generated .DONE file when using the OpenCV-based CLI
        helper script.

    """

    def __init__(self, L, mm, seconds_per_frame):
        """Constructor.

        Parameters
        ----------
        L : float
            Height of the microgenerator tube in mm.
        mm : float
            Height of the moving magnet assembly in mm.
        seconds_per_frame : float
            Number of seconds per frame / datapoint.
            This is typically found in the `subsampled_seconds_per_frame` key
            of the generated .DONE file when using the OpenCV-based CLI
            helper script.

        """
        self.L = L
        self.mm = mm
        self.spf = seconds_per_frame

    def fit_transform(self, groundtruth_dataframe, impute_missing_values=False, pixel_scale=None):
        """
        Process and transform the `groundtruth_dataframe` that is generated by
        the OpenCV-based CLI helper script and return the position of the moving
        magnet assembly in mm, relative to the top of the fixed magnet.

        Parameters
        ----------
        groundtruth_dataframe : dataframe
            Dataframe generated by the OpenCV-based CLI helper script.
        impute_missing_values : bool
            If values were unlabelled (usually due to shaking of the camera),
            attempt to impute them by calculating the moving magnet's
            velocity at the previous time stemp.
            Default value is False.
        pixel_scale : float, optional
            Manually specify the pixel scale to use (in mm per pixel).
            Default value is None.

        Returns
        -------
        numpy array
            Position of the bottom of the magnet assembly relative to the
            top of the fixed magnet.

        numpy array
            Timestamp of each position.

        """
        df = groundtruth_dataframe

        # TODO: Add test for this case.
        # check if the pixel-scale has been defined
        if pixel_scale is None:
            missing_pixel_scale = np.any(df['y_pixel_scale'] == -1)
            if missing_pixel_scale:
                raise ValueError('Dataframe contains missing pixel scale values and the pixel scale is not been '
                                 'manually specified.')
        else:
            df['y_pixel_scale'] = pixel_scale

        df['y'] = np.abs(df['end_y'] - df['start_y'])  # Get position metric
        df['y_mm'] = df['y'] * df['y_pixel_scale']  # Adjust for pixel scale
        df['y_prime_mm'] = df['y_mm']  # Get actual position
        df.loc[df['top_of_magnet'] == 1, 'y_prime_mm'] = df['y_prime_mm'] - self.mm

        if impute_missing_values:
            missing_indexes = df.query('start_y == -1').index.values
            df = impute_missing(df, missing_indexes)

        timestamps = np.arange(0, round(len(df) * self.spf, 8), self.spf)

        return df['y_prime_mm'].values / 1000, timestamps


def impute_missing(df_missing, indexes):
    """Impute missing values from the labeled video data.

    The missing values are imputed by calculating the velocity of the magnet
    assembly from the previous two timestamps and inferring a displacement
    based on that.
    """
    for index in indexes:
        start_velocity_calc = index - 2
        end_velocity_calc = index - 1

        # sanity check
        if df_missing.loc[start_velocity_calc, 'start_y'] == -1 or df_missing.loc[end_velocity_calc, 'start_y'] == -1:
            warnings.warn('Warning: unable to impute all missing values.')
            break

        velocity = df_missing.loc[end_velocity_calc, 'y_prime_mm'] - df_missing.loc[start_velocity_calc, 'y_prime_mm']
        df_missing.loc[index, 'y_prime_mm'] = df_missing.loc[index - 1, 'y_prime_mm'] + velocity
    return df_missing


class MechanicalSystemEvaluator(object):
    """Evaluate the accuracy of a mechanical system model's output

    Attributes
    ----------
    y_target : ndarray
        The target.
    time_target : ndarray
        The timestamps for each element in `y_target`.
    y_predict : ndarray
        The predicted values of the target.
    time_predict : ndarray
        The timestamps for each element in `y_predict`.
    y_target_ : ndarray
        The resampled target values. This attribute is used for producing
        the final plot using the `poof` method.
    y_predict_ : ndarray
        The resampled predicted values. This attribute is used for producing
        the final plot using the `poof` method.
    time_ : ndarray
        The corresponding, shared, timestamps of `y_target_` and `y_predict_`.
        This attribute is used for producing the final plot using the `poof`
        method.
    y_target_warped_ : ndarray
        The dynamically time-warped points of the target values. Each point
        matches with the corresponding points in `self.y_predict_warped_`.
        Generated by calling the `score` method.
    y_predict_warped_ : ndarray
        The dynamically time-warped points of the predicted values. Each point
        matches with the corresponding points in `self.y_target_warped_`.
        Generated by calling the `score` method.

    """

    def __init__(self, y_target, time_target):
        """Constructor

        Parameters
        ----------
        y_target : ndarray
            The target values that the mechanical system model is
            attempting to predict. This is the "ground truth" that the
            prediction will be compared against.
        time_target : ndarray
            The corresponding timestamps of the values in `y_target`

        """
        if len(y_target) != len(time_target):
            raise ValueError('`y_target` and `time_target` must be equal in length.')

        # Holds original values
        self.y_target = y_target
        self.time_target = time_target
        self.y_predict = None
        self.time_predict = None

        # Holds resampled values
        self.y_target_ = None
        self.y_predict_ = None
        self.time_ = None

        # Holds dynamic time-warped values
        self.y_target_warped_ = None
        self.y_predict_warped_ = None

    def fit(self, y_predict, time_predict):
        """Align `y_predicted` and `y_target` in time.

        This allows the target and prediction to later be plotted overlaying
        one another.

        Parameters
        ----------
        y_predict : ndarray
            The predicted values from the mechanical system model.
        time_predict : ndarray
            The corresponding timestamps of the values in `y_predicted`.

        """
        self._fit(y_predict, time_predict)

    def _fit(self, y_predict, time_predict):
        """Execute routine called with by the `fit` class method."""

        self.y_predict = y_predict
        self.time_predict = time_predict

        # Resample the signals to the same sampling frequency
        stop_time = np.max([self.time_target[-1], time_predict[-1]])
        self._clip_time = np.min([self.time_target[-1], time_predict[-1]])

        resampled_time, resampled_y_target = self._interpolate_and_resample(
            self.time_target,
            self.y_target,
            new_x_range=(0, stop_time)
        )

        _, resampled_y_predicted = self._interpolate_and_resample(
            time_predict,
            y_predict,
            new_x_range=(0, stop_time)
        )

        # Remove the delay between the signals
        sample_delay = calc_sample_delay(resampled_y_target,
                                         resampled_y_predicted)

        time_delay = resampled_time[sample_delay]
        _, resampled_y_predicted = self._interpolate_and_resample(resampled_time - time_delay,
                                                                  resampled_y_predicted,
                                                                  new_x_range=[0, stop_time])
        # Store results
        self.y_target_ = resampled_y_target
        self.y_predict_ = resampled_y_predicted
        self.time_ = resampled_time

    # TODO: Place in `utils`
    @staticmethod
    def _interpolate_and_resample(x, y, num_samples=10000, new_x_range=None):
        """Resample a signal using interpolation"""
        interp = UnivariateSpline(x, y, s=0, ext='zeros')

        if new_x_range is not None:
            x_start = new_x_range[0]
            x_stop = new_x_range[1]
        else:
            x_start = 0
            x_stop = np.max(x)

        new_x = np.linspace(x_start, x_stop, num_samples)
        return new_x, interp(new_x)


    def fit_transform(self, y_predict, time_predict):
        """Align `y_predicted` and `y_target` in time.

        This allows the target and prediction to later be plotted overlaying
        one another.

        The `fit_transform` class method returns the `y_predicted` values with
        its shifted timestamps.

        Parameters
        ----------
        y_predict : ndarray, optional
            The predicted values from the mechanical system model.
        time_predict : ndarray, optional
            The corresponding timestamps of the values in `y_predicted`.

        """
        self._fit(y_predict, time_predict)
        return self.time_, self.y_predict_

    def score(self, **metrics):
        """Score the predicted y values and (optionally) plot the DTW curve."""
        results = self._score(**metrics)
        return results

    def _score(self, **metrics):
        """Calculate the score of the predicted y values."""

        # Exclude trailing "steady-state" predictions.
        clip_index = np.argmin(np.abs(self.time_ - self._clip_time))

        self.y_predict_warped_, self.y_target_warped_ = warp_signals(self.y_predict_[:clip_index],
                                                                     self.y_target_[:clip_index])

        metric_results = apply_scalar_functions(self.y_predict_warped_,
                                                self.y_target_warped_,
                                                **metrics)
        # Output "Score" class
        Results = namedtuple('Score', metric_results.keys())

        return Results(*metric_results.values())

    def poof(self, include_dtw=False, **kwargs):
        """
        Plot y_target and y_predicted.

        Also plot the time-warped versions if they have been calculated using
        the `score` method.
        """
        plt.plot(self.time_, self.y_target_, label='Target', **kwargs)
        plt.plot(self.time_, self.y_predict_, label='Prediction', **kwargs)
        plt.legend()

        if include_dtw:
            plt.figure()
            plt.plot(self.y_target_warped_, label='Target, time-warped')
            plt.plot(self.y_predict_warped_, label='Prediction, time-warped')
            plt.legend()

        plt.show()
