import numpy as np
from scipy.interpolate import UnivariateSpline
from scipy.signal import correlate

from unified_model.utils.utils import _smooth_butterworth


class AdcProcessor:
    """Post-processor for measured ADC data using Teensy logger.

    Attributes
    ----------
    voltage_divison_ratio : float
        The ratio of the voltage divider that was used when measuring a
        voltage using the ADC. Equal to (input voltage) / (measured voltage)
    smooth : bool
        Whether to smooth the ADC readings using a low-pass filter in order
        to remove some noise.
        Default is True.
    **smooth_kwargs :
        Keyword arguments passed to the _smooth_butterworth function.

    """

    def __init__(self, voltage_division_ratio=1., smooth=True, **smooth_kwargs):
        """Constructor

        Parameters
        ----------
        voltage_divison_ratio : float
            The ratio of the voltage divider that was used when measuring a
            voltage using the ADC. Equal to (input voltage) / (measured voltage)
        smooth : bool
            Whether to smooth the ADC readings using a low-pass filter in order
            to remove some noise.
            Default is True.
        **smooth_kwargs :
            Keyword arguments passed to the _smooth_butterworth function.

        See Also
        --------
        unified_model.utils.utils._smooth_butterworth : function
            Function used to perform the smoothing

        """
        self.voltage_division_ratio = voltage_division_ratio
        self.smooth = smooth
        self.smooth_kwargs = smooth_kwargs if not None else None

    def fit_transform(self,
                      groundtruth_dataframe,
                      voltage_col='V',
                      time_col='time(ms)'):
        """
        Extract and transform the voltage in pandas dataframe
        `groundtruth_dataframe` into a clean signal and normalize to the correct
        voltage.

        Parameters
        ----------
        groundtruth_dataframe : pandas dataframe
            Dataframe generated by reading in the .csv file generated by
            parsing the log files on the SD card of the data logger.
        voltage_col : string
            Column in `groundtruth_dataframe` containing the voltage readings.
        time_col : string
            Column in `groundtruth_dataframe` containing the timestamps of the
            voltage readings. Note: this is not used for any calculations.

        Returns
        -------
        numpy array
            True measured output voltage.

        numpy array
            Timestamps of each voltage measurement.
        """
        voltage_readings = groundtruth_dataframe[voltage_col].values

        if self.smooth:
            critical_frequency = self.smooth_kwargs.pop('critical_frequency', 1/4)
            voltage_readings = _smooth_butterworth(voltage_readings, critical_frequency)

        voltage_readings = voltage_readings * self.voltage_division_ratio
        voltage_readings = voltage_readings - np.mean(voltage_readings)

        return voltage_readings, groundtruth_dataframe[time_col].values / 1000

# TODO: Write tests
# TODO: Add documentation
class ElectricalSystemEvaluator:
    """Evaluate the accuracy of an electrical system model's output."""

    def __init__(self, emf_target, time_target):
        """Constructor"""

        self.emf_target = emf_target
        self.time_target = time_target

        self.resampled_emf_target = None
        self.resampled_time_target = None


        self.resampled_emf_pred = None
        self.resampled_time_pred = None

        if not self._is_period_constant(time_target):
            raise RuntimeWarning('Timestamps for the target values are not constant \
            and this may lead to undesirable behaviour.')

    def fit(self, emf_predicted, time_predicted):
        self._fit(emf_predicted, time_predicted)

    def _fit(self, emf_predicted, time_predicted):

        if not self._is_period_constant(time_predicted):
            raise RuntimeWarning('Timestamps for the predicted values are not constant \
            and this may lead to undesirable behaviour.')

        # Normalize
        emf_predicted = np.abs(emf_predicted)

        # Build interpolators in order to resample.
        interp_target = UnivariateSpline(self.time_target,
                                         self.emf_target,
                                         s=0,
                                         ext='zeros')
        interp_pred = UnivariateSpline(time_predicted,
                                       emf_predicted,
                                       s=0,
                                       ext='zeros')

        # Resample
        stop_time = np.max([self.time_target[-1], time_predicted[-1]])
        self.resampled_timestamps = np.linspace(0, stop_time, 10000)
        resampled_emf_target = interp_target(self.resampled_timestamps)
        resampled_emf_pred = interp_pred(self.resampled_timestamps)

        # Calculate delay using cross-correlation
        corr_1 = correlate(resampled_emf_pred, resampled_emf_target)
        corr_2 = correlate(resampled_emf_target, resampled_emf_pred)
        sample_offset = int((np.abs(np.argmax(corr_1) - np.argmax(corr_2)))/2)
        time_offset = self.resampled_timestamps[sample_offset]

        # TODO: Design some mechanism to shift the correct signal
        # TODO: For now, we're assuming the predicted signal is
        # TODO: always leading.
        # Compensate for delay

        interp_pred = UnivariateSpline(self.resampled_timestamps + time_offset,
                                       resampled_emf_pred,
                                       s=0,
                                       ext='zeros')
        resampled_emf_pred = interp_pred(self.resampled_timestamps)

        self.resampled_emf_target = resampled_emf_target
        self.resampled_emf_pred = resampled_emf_pred

    def _is_period_constant(self, arr):
        """Return True if the difference between values in `arr` are constant"""
        diff = np.diff(arr)
        diff = np.array([round(val, 8) for val in diff])  # Handle rounding
        if len(np.unique(diff)) > 1:
            return False
        return True
